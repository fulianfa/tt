import { RawNodeData, TreeNode, ParseResult } from '../types';

/**
 * Parses raw text content into an array of RawNodeData objects.
 */
export const parseRawLines = (content: string): RawNodeData[] => {
  const lines = content.split('\n');
  const nodes: RawNodeData[] = [];
  
  // Regex Breakdown:
  // ^\s*                  : Start of line, optional whitespace
  // (?:(\d+)\s+)?         : Optional Index (Group 1)
  // (\([^)]+\))           : Role (Group 2)
  // \s+                   : Whitespace
  // ([a-fA-F0-9]{12})     : MAC (Group 3)
  // \s+                   : Whitespace
  // (0x[a-fA-F0-9]+)      : TEI (Group 4)
  // \s+                   : Whitespace
  // (\d+)                 : Ro (Group 5)
  // \s+                   : Whitespace
  // ([a-fA-F0-9]+)        : PCO (Group 6)
  // \s+                   : Whitespace
  // (\d+)                 : LV (Group 7)
  // \s+                   : Whitespace
  // ([a-fA-F0-9]+)        : NxH (Group 8)
  // \s+                   : Whitespace
  // (-?\d+)               : RSSI (Group 9)
  // \s+                   : Whitespace
  // (-?\d+)               : SNR (Group 10)
  
  const lineRegex = /^\s*(?:(\d+)\s+)?(\([^)]+\))\s+([a-fA-F0-9]{12})\s+(0x[a-fA-F0-9]+)\s+(\d+)\s+([a-fA-F0-9]+)\s+(\d+)\s+([a-fA-F0-9]+)\s+(-?\d+)\s+(-?\d+)/;

  lines.forEach((line, i) => {
    const trimmed = line.trim();
    if (!trimmed) return;

    const match = trimmed.match(lineRegex);
    if (match) {
      try {
        const rawNode: RawNodeData = {
          index: match[1] ? parseInt(match[1], 10) : i + 1,
          role: match[2],
          mac: match[3],
          tei: match[4],
          teiDec: parseInt(match[4], 16),
          ro: parseInt(match[5], 10),
          pco: match[6],
          pcoDec: parseInt(match[6], 16),
          level: parseInt(match[7], 10),
          nxh: match[8],
          rssi: parseInt(match[9], 10),
          snr: parseInt(match[10], 10),
          rawLine: trimmed,
        };
        nodes.push(rawNode);
      } catch (e) {
        console.warn('Failed to parse line values:', trimmed, e);
      }
    }
  });

  return nodes;
};

/**
 * Builds the tree structure from a flat list of nodes.
 */
export const buildTree = (nodes: RawNodeData[]): TreeNode | null => {
  if (nodes.length === 0) return null;

  const rootTeiDec = 1; // 0x01
  const nodeMap = new Map<number, TreeNode>();

  // Create TreeNode wrappers
  nodes.forEach(node => {
    // Avoid duplicates if merging manual nodes with file nodes, prioritize last added if needed,
    // but here we just ensure we don't crash on duplicates.
    // If we want manual nodes to overwrite, we should handle that before calling buildTree or map based on unique key.
    // Here we use TEI as unique key.
    nodeMap.set(node.teiDec, {
        name: node.tei,
        attributes: node,
        children: []
    });
  });

  // Check if Root exists in the list
  let rootNode = nodeMap.get(rootTeiDec);

  if (!rootNode) {
    // Determine if we need a virtual root. 
    const hasChildrenOfRoot = nodes.some(n => n.pcoDec === rootTeiDec);
    
    if (hasChildrenOfRoot) {
      const virtualRootData: RawNodeData = {
        index: 0,
        mac: 'ROOT_CCO',
        tei: '0x001',
        teiDec: 1,
        role: '(CCO)',
        ro: 0,
        pco: '000',
        pcoDec: 0,
        level: 1,
        nxh: '000',
        rssi: 0,
        snr: 0,
        rawLine: 'Virtual Root generated by system',
      };
      
      rootNode = {
        name: '0x001 (CCO)',
        attributes: virtualRootData,
        children: []
      };
      nodeMap.set(rootTeiDec, rootNode);
    }
  }

  // Fallback: orphan search
  if (!rootNode) {
    const teiSet = new Set(nodes.map(n => n.teiDec));
    const orphans = nodes.filter(n => !teiSet.has(n.pcoDec));
    
    if (orphans.length === 1) {
       rootNode = nodeMap.get(orphans[0].teiDec) || null;
    } else if (orphans.length > 1) {
       // Multiple roots? Create a super-root.
       const superRootData: RawNodeData = {
        index: -1, mac: 'SUPER_ROOT', tei: 'ROOT', teiDec: -1, role: 'ROOT',
        ro: 0, pco: '0', pcoDec: 0, level: 0, nxh: '0', rssi: 0, snr: 0, rawLine: ''
       };
       rootNode = { name: 'Root', attributes: superRootData, children: [] };
       orphans.forEach(o => {
         const child = nodeMap.get(o.teiDec);
         if (child) rootNode!.children.push(child);
       });
    }
  }

  // Link children
  nodes.forEach(node => {
    if (rootNode && node.teiDec === rootNode.attributes.teiDec) return;
    
    const parent = nodeMap.get(node.pcoDec);
    if (parent) {
      const childNode = nodeMap.get(node.teiDec);
      if (childNode) {
         // Avoid circular or duplicate adding
         if (!parent.children.includes(childNode)) {
            parent.children.push(childNode);
         }
      }
    }
  });

  return rootNode || null;
};

export const parseTopologyFile = (content: string): ParseResult => {
    const nodes = parseRawLines(content);
    if (nodes.length === 0) {
        return { nodes: [], root: null, error: "No valid data lines found. Please check the file format." };
    }
    const root = buildTree(nodes);
    return { nodes, root };
};